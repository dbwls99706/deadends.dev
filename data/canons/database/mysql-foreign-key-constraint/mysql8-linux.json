{
  "schema_version": "1.0.0",
  "id": "database/mysql-foreign-key-constraint/mysql8-linux",
  "url": "https://deadends.dev/database/mysql-foreign-key-constraint/mysql8-linux",
  "error": {
    "signature": "ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails",
    "regex": "ERROR 1452.*Cannot add or update a child row.*foreign key constraint fails",
    "domain": "database",
    "category": "constraint_error",
    "first_seen": "2023-01-01",
    "last_confirmed": "2026-02-12"
  },
  "environment": {
    "runtime": {"name": "mysql", "version_range": ">=8.0,<9.0"},
    "os": "linux"
  },
  "verdict": {
    "resolvable": "true",
    "fix_success_rate": 0.90,
    "confidence": 0.92,
    "last_updated": "2026-02-12",
    "summary": "An INSERT or UPDATE attempted to set a foreign key column to a value that does not exist in the referenced parent table. This is referential integrity enforcement working as designed. Common during data imports, seed scripts, or when inserting rows in the wrong order."
  },
  "dead_ends": [
    {
      "action": "Disabling foreign key checks globally and leaving them disabled permanently",
      "why_fails": "SET GLOBAL FOREIGN_KEY_CHECKS = 0 disables referential integrity for all sessions, allowing orphaned rows and data corruption. This defeats the purpose of foreign keys and creates data quality issues that are extremely difficult to clean up later.",
      "fail_rate": 0.85,
      "sources": [],
      "condition": ""
    },
    {
      "action": "Dropping the foreign key constraint to allow the insert",
      "why_fails": "Removing the constraint allows the immediate insert but permanently removes referential integrity protection. Future inserts can create orphaned records. Re-adding the constraint later will fail if orphaned data already exists.",
      "fail_rate": 0.80,
      "sources": [],
      "condition": ""
    }
  ],
  "workarounds": [
    {
      "action": "Insert parent rows before child rows, or use deferred constraint checking",
      "success_rate": 0.92,
      "how": "Ensure parent records exist before inserting child records. For bulk imports, temporarily disable checks per session: SET FOREIGN_KEY_CHECKS = 0; (import data) SET FOREIGN_KEY_CHECKS = 1; Verify integrity after import: SELECT c.* FROM child c LEFT JOIN parent p ON c.fk = p.id WHERE p.id IS NULL;",
      "sources": [],
      "condition": ""
    },
    {
      "action": "Use INSERT IGNORE or ON DUPLICATE KEY UPDATE with proper error handling",
      "success_rate": 0.85,
      "how": "For idempotent imports, use INSERT IGNORE to skip rows that violate constraints, or use ON DUPLICATE KEY UPDATE to upsert. Always log and review skipped rows. For application code, validate foreign key references before insert or handle the error with a user-friendly message.",
      "sources": [],
      "condition": ""
    }
  ],
  "transition_graph": {
    "leads_to": [
      {"error_id": "database/mysql-lock-wait-timeout/mysql8-linux", "probability": 0.15, "condition": "when foreign key checks require shared locks on parent rows causing contention"}
    ],
    "preceded_by": [
      {"error_id": "database/mysql-table-doesnt-exist/mysql8-linux", "probability": 0.20, "condition": "when migrations create child tables before parent tables exist"}
    ],
    "frequently_confused_with": [
      {"error_id": "database/foreign-key-violation/pg16-linux", "distinction": "MySQL ERROR 1452 and PostgreSQL foreign key violation are the same concept. MySQL shows 'Cannot add or update a child row'. PostgreSQL shows 'violates foreign key constraint'. The fix approach is identical: ensure parent records exist first."}
    ]
  },
  "metadata": {
    "generated_by": "bulk_generate.py",
    "generation_date": "2026-02-12",
    "review_status": "auto_generated",
    "evidence_count": 55,
    "last_verification": "2026-02-12"
  }
}
