{
  "schema_version": "1.0.0",
  "id": "docker/compose-depends-on-unhealthy/docker27-linux",
  "url": "https://deadends.dev/docker/compose-depends-on-unhealthy/docker27-linux",
  "error": {
    "signature": "dependency failed to start: container X is unhealthy",
    "regex": "dependency failed to start: container .+ is unhealthy",
    "domain": "docker",
    "category": "compose_error",
    "first_seen": "2022-01-01",
    "last_confirmed": "2026-02-01"
  },
  "environment": {
    "runtime": {
      "name": "docker-compose",
      "version_range": ">=2.0.0"
    },
    "os": "linux",
    "python": "",
    "additional": {
      "common_contexts": [
        "docker compose v2",
        "development environment",
        "database initialization",
        "service orchestration"
      ]
    }
  },
  "verdict": {
    "resolvable": "true",
    "fix_success_rate": 0.91,
    "confidence": 0.91,
    "last_updated": "2026-02-01",
    "summary": "The dependency service's healthcheck is failing or missing. Docker Compose v2 requires explicit healthchecks with 'depends_on: condition: service_healthy'. The most common cause is a missing or incorrect healthcheck definition."
  },
  "dead_ends": [
    {
      "action": "Adding sleep commands in entrypoint scripts as a wait mechanism",
      "why_fails": "Sleep-based waits are brittle and slow. They do not actually check service health and fail silently if the dependency takes longer than the sleep duration. Docker Compose v2 has native health-check-based waiting.",
      "fail_rate": 0.75,
      "sources": [
        "https://docs.docker.com/compose/compose-file/"
      ],
      "common_misconception": "Fixed-duration sleeps are treated as reliable service readiness checks."
    },
    {
      "action": "Removing depends_on to let services start in parallel",
      "why_fails": "Services start simultaneously with no ordering, causing 'connection refused' errors when the application starts before the database is ready. This makes the problem worse by trading a clear error for intermittent failures.",
      "fail_rate": 0.88,
      "sources": [
        "https://docs.docker.com/compose/compose-file/"
      ],
      "common_misconception": "Removing dependencies eliminates dependency-related errors."
    },
    {
      "action": "Setting restart: always to keep retrying the dependent service",
      "why_fails": "Creates an infinite restart loop: service fails → restarts → fails again. The dependency never becomes healthy just because the dependent restarts. Consumes resources and fills logs with repeated failures.",
      "fail_rate": 0.82,
      "sources": [
        "https://docs.docker.com/compose/compose-file/"
      ],
      "common_misconception": "Restart policies are a substitute for proper startup ordering."
    }
  ],
  "workarounds": [
    {
      "action": "Add a proper healthcheck to the dependency service",
      "how": "In docker-compose.yml, add a healthcheck to the dependency. For PostgreSQL: healthcheck: { test: ['CMD-SHELL', 'pg_isready -U postgres'], interval: 5s, timeout: 5s, retries: 5 }. For MySQL: test: ['CMD', 'mysqladmin', 'ping', '-h', 'localhost']. For Redis: test: ['CMD', 'redis-cli', 'ping']. Then use depends_on: { db: { condition: service_healthy } }.",
      "success_rate": 0.94,
      "tradeoff": "Adds healthcheck configuration to compose file",
      "sources": [
        "https://docs.docker.com/compose/compose-file/05-services/#healthcheck"
      ]
    },
    {
      "action": "Use wait-for-it.sh or dockerize as entrypoint wrapper",
      "how": "Add wait-for-it.sh to your image and use as entrypoint: entrypoint: ['./wait-for-it.sh', 'db:5432', '--', 'node', 'server.js']. This polls the port until the dependency is accepting connections before starting the application.",
      "success_rate": 0.88,
      "tradeoff": "Requires adding the script to the Docker image",
      "sources": [
        "https://github.com/vishnubob/wait-for-it"
      ]
    },
    {
      "action": "Ensure healthcheck tests actual readiness, not just port availability",
      "how": "A TCP port check (nc -z) returns true before the database is ready to accept queries. Use service-specific readiness commands: pg_isready for PostgreSQL, mysqladmin ping for MySQL, redis-cli ping for Redis, curl localhost:9200/_cluster/health for Elasticsearch.",
      "success_rate": 0.9,
      "tradeoff": "Requires knowing the correct readiness command for each service",
      "sources": []
    }
  ],
  "transition_graph": {
    "leads_to": [],
    "preceded_by": [],
    "frequently_confused_with": [
      {
        "error_id": "docker/compose-service-depends-on/docker27-linux",
        "distinction": "'dependency failed to start: unhealthy' means the healthcheck is failing. Generic depends_on errors may mean the service crashed or was not defined. Different root causes require different fixes."
      }
    ]
  },
  "metadata": {
    "generated_by": "manual",
    "generation_date": "2026-02-14",
    "review_status": "human_reviewed",
    "evidence_count": 55,
    "page_views": 0,
    "ai_agent_hits": 0,
    "human_hits": 0,
    "last_verification": "2026-02-14"
  }
}
