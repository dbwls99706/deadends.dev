{
  "schema_version": "1.0.0",
  "id": "dotnet/invalid-cast-exception/dotnet8-linux",
  "url": "https://deadends.dev/dotnet/invalid-cast-exception/dotnet8-linux",
  "error": {
    "signature": "System.InvalidCastException: Unable to cast object of type 'X' to type 'Y'.",
    "regex": "(InvalidCastException|Unable to cast object of type .+ to type)",
    "domain": "dotnet",
    "category": "runtime_exception",
    "first_seen": "2023-01-01",
    "last_confirmed": "2026-02-13"
  },
  "environment": {
    "runtime": {
      "name": "dotnet",
      "version_range": ">=8.0,<9.0"
    },
    "os": "linux"
  },
  "verdict": {
    "resolvable": "true",
    "fix_success_rate": 0.89,
    "confidence": 0.9,
    "last_updated": "2026-02-13",
    "summary": "InvalidCastException occurs when an explicit cast or unboxing operation fails at runtime because the actual object type is not compatible with the target type. Common scenarios include: casting objects from untyped collections (ArrayList, DataRow fields), incorrect unboxing of value types (e.g., casting an int boxed as object to long), COM interop type mismatches, and interface cast failures when the same assembly is loaded from different paths. On .NET 8 Linux, a particularly common cause is assembly loading contexts where the 'same' type loaded from different AssemblyLoadContexts are treated as distinct types. Fix by using safe casting patterns (as/is), proper generic collections, and ensuring consistent assembly loading."
  },
  "dead_ends": [
    {
      "action": "Suppressing the exception by wrapping every cast in try-catch and returning a default value",
      "why_fails": "This masks the real type mismatch and leads to silent data corruption or logic errors downstream. The cast failure indicates a fundamental type contract violation that needs to be understood and fixed, not hidden. Default values propagating through the system create bugs that are much harder to diagnose later",
      "fail_rate": 0.9,
      "sources": [
        "https://learn.microsoft.com/en-us/dotnet/api/"
      ],
      "condition": ""
    },
    {
      "action": "Using Convert.ChangeType() as a universal replacement for direct casts",
      "why_fails": "Convert.ChangeType() only works for types that implement IConvertible (primitive types, string, DateTime). It will throw InvalidCastException or FormatException for custom types, complex objects, and many framework types. It also does not handle nullable types correctly, throwing for Nullable<T> targets",
      "fail_rate": 0.75,
      "sources": [
        "https://learn.microsoft.com/en-us/dotnet/api/"
      ],
      "condition": "When dealing with custom types or nullable value types"
    },
    {
      "action": "Assuming the cast fails because of an inheritance issue and adding a base class or interface",
      "why_fails": "When the types look identical but the cast fails (common error message: 'Unable to cast Type to Type' with same names), the issue is usually assembly loading: the same type loaded from two different assembly contexts are distinct CLR types. Adding inheritance relationships does not help because the runtime sees them as completely unrelated types from different assemblies",
      "fail_rate": 0.85,
      "sources": [
        "https://learn.microsoft.com/en-us/dotnet/api/"
      ],
      "condition": "When source and target type names appear identical in the error message"
    }
  ],
  "workarounds": [
    {
      "action": "Use pattern matching or the 'as' operator with null checks instead of direct casts",
      "success_rate": 0.92,
      "how": "Replace direct casts with safe patterns: instead of var result = (MyType)obj; use if (obj is MyType result) { /* use result */ } else { /* handle mismatch, log obj.GetType().AssemblyQualifiedName */ }. For value type unboxing, ensure the exact type matches: an int boxed as object must be unboxed to int first, then converted: var value = (long)(int)obj; not (long)obj. Use pattern matching with type checks for polymorphic scenarios",
      "sources": [],
      "condition": ""
    },
    {
      "action": "Replace untyped collections with generic equivalents to get compile-time type safety",
      "success_rate": 0.9,
      "how": "Replace ArrayList with List<T>, Hashtable with Dictionary<TKey, TValue>, and DataRow field access with strongly-typed models. For DataRow: instead of (decimal)row[\"Price\"], use row.Field<decimal>(\"Price\") which handles DBNull and performs proper type conversion. For legacy APIs returning object, create typed wrapper methods: public static T GetValue<T>(DataRow row, string column) => row.IsNull(column) ? default! : row.Field<T>(column);",
      "sources": [],
      "condition": ""
    },
    {
      "action": "Fix assembly loading context issues by ensuring a single copy of shared types",
      "success_rate": 0.85,
      "how": "When the error shows the same type name for source and target (e.g., 'Unable to cast MyApp.Models.User to MyApp.Models.User'), the type is loaded from different assembly contexts. Diagnose with: Console.WriteLine(obj.GetType().Assembly.Location); Console.WriteLine(typeof(MyType).Assembly.Location); Fix by ensuring plugins or dynamically loaded assemblies share the host's types via AssemblyLoadContext.Default or by using a shared contract assembly. In plugin scenarios, configure the AssemblyDependencyResolver to resolve shared types from the host context",
      "sources": [],
      "condition": "When using plugins, AssemblyLoadContext, or dynamically loaded assemblies"
    }
  ],
  "transition_graph": {
    "leads_to": [
      {
        "error_id": "dotnet/nullreferenceexception/dotnet8-linux",
        "probability": 0.2,
        "condition": "when developers replace casts with 'as' operator but forget to handle the null result"
      },
      {
        "error_id": "dotnet/invalidoperationexception/dotnet8-linux",
        "probability": 0.1,
        "condition": "when incorrect type casts cause downstream LINQ or collection operations to fail"
      }
    ],
    "preceded_by": [
      {
        "error_id": "dotnet/serialization-cycle/dotnet8-linux",
        "probability": 0.1,
        "condition": "when deserializing JSON to incorrect target types"
      },
      {
        "error_id": "dotnet/ef-migration-failed/dotnet8-linux",
        "probability": 0.05,
        "condition": "when EF model changes cause database column type mismatches"
      }
    ],
    "frequently_confused_with": [
      {
        "error_id": "dotnet/argumentexception/dotnet8-linux",
        "distinction": "ArgumentException is thrown when a method explicitly validates its parameters and rejects an argument; InvalidCastException is thrown by the runtime when a cast or unboxing operation encounters an incompatible type at runtime"
      }
    ]
  },
  "metadata": {
    "generated_by": "bulk_generate.py",
    "generation_date": "2026-02-13",
    "review_status": "auto_generated",
    "evidence_count": 80,
    "last_verification": "2026-02-13"
  }
}
