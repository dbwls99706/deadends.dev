{
  "schema_version": "1.0.0",
  "id": "dotnet/target-invocation-exception/dotnet8-linux",
  "url": "https://deadends.dev/dotnet/target-invocation-exception/dotnet8-linux",
  "error": {
    "signature": "System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation.",
    "regex": "(TargetInvocationException|Exception has been thrown by the target of an invocation)",
    "domain": "dotnet",
    "category": "reflection_error",
    "first_seen": "2023-01-01",
    "last_confirmed": "2026-02-13"
  },
  "environment": {
    "runtime": {
      "name": "dotnet",
      "version_range": ">=8.0,<9.0"
    },
    "os": "linux"
  },
  "verdict": {
    "resolvable": "true",
    "fix_success_rate": 0.85,
    "confidence": 0.88,
    "last_updated": "2026-02-13",
    "summary": "TargetInvocationException is a wrapper exception thrown by .NET reflection APIs (MethodInfo.Invoke, Activator.CreateInstance, ConstructorInfo.Invoke, PropertyInfo.SetValue, etc.) when the invoked method or constructor throws an exception internally. The actual error is always in the InnerException. This exception is extremely common in DI containers, serialization frameworks, source generators at runtime, MVC model binding, and any framework that uses reflection to instantiate types or invoke methods. On .NET 8 Linux, additional causes include missing native dependencies during reflected constructor calls and trimming-related issues when using AOT compilation. Fix by inspecting InnerException, and where possible, replacing reflection with source generators or compile-time approaches."
  },
  "dead_ends": [
    {
      "action": "Debugging based on the outer TargetInvocationException message and stack trace",
      "why_fails": "The outer exception message is always the same generic string ('Exception has been thrown by the target of an invocation') and the outer stack trace points to the reflection infrastructure (MethodBase.Invoke, RuntimeMethodHandle.InvokeMethod), not to the actual failing code. All diagnostic information is in InnerException. Developers who do not unwrap the InnerException waste time investigating the reflection call site instead of the actual error location",
      "fail_rate": 0.85,
      "sources": [
        "https://learn.microsoft.com/en-us/dotnet/api/"
      ],
      "condition": ""
    },
    {
      "action": "Catching TargetInvocationException and re-throwing without preserving the inner exception",
      "why_fails": "Using 'throw ex.InnerException;' resets the stack trace, losing the original call site information. Using 'throw;' re-throws the TargetInvocationException wrapper, which is not helpful. Both approaches lose critical debugging information. The correct unwrapping requires ExceptionDispatchInfo to preserve the original stack trace",
      "fail_rate": 0.8,
      "sources": [
        "https://learn.microsoft.com/en-us/dotnet/api/"
      ],
      "condition": ""
    },
    {
      "action": "Adding [DebuggerStepThrough] or [DebuggerHidden] attributes to suppress the exception in the debugger",
      "why_fails": "These attributes only affect the debugger experience and do not fix the underlying exception. The TargetInvocationException still occurs at runtime. In production, the same error will crash the application or produce incorrect behavior. These attributes just make the error harder to diagnose during development",
      "fail_rate": 0.95,
      "sources": [
        "https://learn.microsoft.com/en-us/dotnet/api/"
      ],
      "condition": ""
    }
  ],
  "workarounds": [
    {
      "action": "Unwrap InnerException using ExceptionDispatchInfo to preserve the original stack trace",
      "success_rate": 0.9,
      "how": "Use ExceptionDispatchInfo to re-throw the inner exception while preserving its original stack trace: try { methodInfo.Invoke(target, args); } catch (TargetInvocationException ex) when (ex.InnerException != null) { ExceptionDispatchInfo.Capture(ex.InnerException).Throw(); }. This gives you the actual exception type and the exact line where the failure occurred inside the invoked method. In logging scenarios: logger.LogError(ex.InnerException, \"Reflected method {Method} failed\", methodInfo.Name);",
      "sources": [],
      "condition": ""
    },
    {
      "action": "Replace reflection-based invocation with compiled delegates or source generators",
      "success_rate": 0.88,
      "how": "For frequently invoked reflected methods, compile to a delegate once: var method = typeof(MyService).GetMethod(\"Process\")!; var func = (Func<MyService, string, Task<Result>>)Delegate.CreateDelegate(typeof(Func<MyService, string, Task<Result>>), method); // Now calls through func() throw the original exception, not TargetInvocationException: var result = await func(service, input); For constructor invocation, use compiled expressions: var ctor = typeof(MyService).GetConstructor(new[] { typeof(ILogger) })!; var param = Expression.Parameter(typeof(ILogger)); var lambda = Expression.Lambda<Func<ILogger, MyService>>(Expression.New(ctor, param), param).Compile();",
      "sources": [],
      "condition": "When the same reflection call is made repeatedly"
    },
    {
      "action": "Use the .NET 8 MethodInvoker or ConstructorInvoker APIs for better performance and exception handling",
      "success_rate": 0.86,
      "how": "In .NET 8, use the new MethodInvoker API that provides better performance and can optionally unwrap exceptions: var invoker = MethodInvoker.Create(methodInfo); try { invoker.Invoke(target, arg1, arg2); } catch (TargetInvocationException ex) { // Still wraps, but the invoker is significantly faster than MethodInfo.Invoke // Use ExceptionDispatchInfo to unwrap as needed ExceptionDispatchInfo.Capture(ex.InnerException!).Throw(); }. For constructors: var ctorInvoker = ConstructorInvoker.Create(constructorInfo); var instance = ctorInvoker.Invoke(arg1);",
      "sources": [],
      "condition": ".NET 8 or later"
    }
  ],
  "transition_graph": {
    "leads_to": [
      {
        "error_id": "dotnet/nullreferenceexception/dotnet8-linux",
        "probability": 0.15,
        "condition": "when the InnerException is a NullReferenceException inside the reflected method"
      },
      {
        "error_id": "dotnet/invalidoperationexception/dotnet8-linux",
        "probability": 0.2,
        "condition": "when the InnerException is an InvalidOperationException from DI or configuration issues inside the invoked constructor"
      }
    ],
    "preceded_by": [
      {
        "error_id": "dotnet/di-circular-dependency/dotnet8-linux",
        "probability": 0.15,
        "condition": "when the DI container uses reflection to construct services and the constructor throws due to a circular dependency"
      },
      {
        "error_id": "dotnet/ambiguous-match/dotnet8-linux",
        "probability": 0.1,
        "condition": "when resolving the wrong overload via reflection and invoking it with incorrect arguments"
      }
    ],
    "frequently_confused_with": [
      {
        "error_id": "dotnet/type-initialization-exception/dotnet8-linux",
        "distinction": "TypeInitializationException wraps failures in static constructors and is cached permanently; TargetInvocationException wraps failures in any reflected method or instance constructor invocation and is thrown fresh each time the invocation is attempted"
      }
    ]
  },
  "metadata": {
    "generated_by": "bulk_generate.py",
    "generation_date": "2026-02-13",
    "review_status": "auto_generated",
    "evidence_count": 80,
    "last_verification": "2026-02-13"
  }
}
