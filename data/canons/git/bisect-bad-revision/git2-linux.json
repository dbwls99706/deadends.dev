{
  "schema_version": "1.0.0",
  "id": "git/bisect-bad-revision/git2-linux",
  "url": "https://deadends.dev/git/bisect-bad-revision/git2-linux",
  "error": {
    "signature": "You need to start by 'git bisect start' \u2014 bisect session not initialized or in bad state",
    "regex": "(?:You need to start by.*git bisect|git bisect.*(?:bad|good|reset|start)|not a valid commit|[Bb]isect.*(?:error|failed|cannot))",
    "domain": "git",
    "category": "workflow_error",
    "first_seen": "2018-01-01",
    "last_confirmed": "2026-02-14"
  },
  "environment": {
    "runtime": {
      "name": "git",
      "version_range": ">=2.0,<3.0"
    },
    "os": "linux",
    "additional": {
      "common_contexts": [
        "Debugging regressions by binary-searching commit history",
        "Finding which commit introduced a bug",
        "CI/CD automated bisection workflows"
      ]
    }
  },
  "verdict": {
    "resolvable": "true",
    "fix_success_rate": 0.9,
    "confidence": 0.88,
    "last_updated": "2026-02-14",
    "summary": "Git bisect errors occur when the bisect session isn't properly initialized, bad/good commits are specified incorrectly, or the session state becomes corrupted. The three-step flow (start -> mark bad -> mark good -> test) must be followed precisely, and forgetting to reset after completion leaves the repo in a detached HEAD state."
  },
  "dead_ends": [
    {
      "action": "Running git bisect good/bad without first running git bisect start",
      "why_fails": "Git bisect requires an active session. Running 'git bisect good' or 'git bisect bad' without 'git bisect start' first results in 'You need to start by git bisect start'. The session must be explicitly initialized.",
      "fail_rate": 0.95,
      "sources": [
        "https://git-scm.com/docs/git-bisect"
      ],
      "condition": ""
    },
    {
      "action": "Forgetting to run git bisect reset after finding the culprit commit",
      "why_fails": "After bisect completes, your repo is left in a detached HEAD state at the culprit commit. If you start making changes or committing without running 'git bisect reset' first, you'll be working on a detached HEAD and may lose work. Always run 'git bisect reset' to return to your original branch.",
      "fail_rate": 0.7,
      "sources": [
        "https://git-scm.com/docs/git-bisect"
      ],
      "condition": ""
    },
    {
      "action": "Marking a commit as both good and bad, or swapping good/bad labels",
      "why_fails": "If you accidentally mark a good commit as bad (or vice versa), bisect will converge on the wrong commit. Git cannot detect this mistake. The result will be a false positive. If the bisect result seems wrong, 'git bisect log' shows your markings for review.",
      "fail_rate": 0.85,
      "sources": [
        "https://git-scm.com/docs/git-bisect"
      ],
      "condition": ""
    }
  ],
  "workarounds": [
    {
      "action": "Follow the correct bisect workflow: start, bad, good, test, repeat, reset",
      "success_rate": 0.95,
      "how": "1) 'git bisect start' 2) 'git bisect bad' (current commit is bad) 3) 'git bisect good <known-good-commit>' 4) Test the code at the checkout point 5) 'git bisect good' or 'git bisect bad' based on test 6) Repeat until git identifies the first bad commit 7) 'git bisect reset' to return to your branch.",
      "sources": [
        "https://git-scm.com/docs/git-bisect"
      ],
      "condition": ""
    },
    {
      "action": "Use git bisect run for automated bisection",
      "success_rate": 0.88,
      "how": "Run 'git bisect run <test-script>' where the script exits 0 for good commits and non-zero for bad. Example: 'git bisect run python -m pytest tests/test_feature.py'. Git automatically checks out commits and runs your test until the first bad commit is found.",
      "tradeoff": "Requires a reliable automated test that can detect the regression",
      "sources": [
        "https://git-scm.com/docs/git-bisect"
      ],
      "condition": "When you have an automated test for the regression"
    },
    {
      "action": "Use git bisect skip for untestable commits",
      "success_rate": 0.82,
      "how": "When a checkout can't be tested (build broken, unrelated failure), use 'git bisect skip' instead of good/bad. Git will try nearby commits. You can also skip ranges: 'git bisect skip <start>..<end>'.",
      "tradeoff": "May narrow to a range of commits rather than a single culprit",
      "sources": [
        "https://git-scm.com/docs/git-bisect"
      ],
      "condition": "When a commit can't be built or tested"
    }
  ],
  "transition_graph": {
    "leads_to": [
      {
        "error_id": "git/detached-head/git2-linux",
        "probability": 0.6,
        "condition": "Bisect leaves repo in detached HEAD state if not properly reset"
      }
    ],
    "preceded_by": [],
    "frequently_confused_with": []
  },
  "metadata": {
    "generated_by": "manual",
    "generation_date": "2026-02-14",
    "review_status": "human_reviewed",
    "evidence_count": 45,
    "last_verification": "2026-02-14"
  }
}
