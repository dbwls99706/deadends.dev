{
  "schema_version": "1.0.0",
  "id": "git/shallow-clone-limitation/git2-linux",
  "url": "https://deadends.dev/git/shallow-clone-limitation/git2-linux",
  "error": {
    "signature": "fatal: shallow file has changed since we read it",
    "regex": "(?:fatal: (?:shallow file has changed|shallow update not allowed)|--unshallow.*fatal)",
    "domain": "git",
    "category": "clone_error",
    "first_seen": "2023-06-01",
    "last_confirmed": "2026-02-14"
  },
  "environment": {
    "runtime": {
      "name": "git",
      "version_range": ">=2.40,<3.0"
    },
    "os": "linux",
    "additional": {
      "common_contexts": [
        "CI/CD pipelines",
        "GitHub Actions with fetch-depth: 1",
        "automated deployment scripts"
      ]
    }
  },
  "verdict": {
    "resolvable": "true",
    "fix_success_rate": 0.91,
    "confidence": 0.89,
    "last_updated": "2026-02-14",
    "summary": "Shallow clones (depth=1) lack full commit history, breaking operations that require ancestry information like git log, git blame, git merge-base, and certain merge strategies. The shallow boundary file can also become stale during concurrent fetches."
  },
  "dead_ends": [
    {
      "action": "Expecting full git log or git blame output to work correctly with --depth=1 clone",
      "why_fails": "A shallow clone with depth=1 only has the tip commit. git log shows a single commit, git blame cannot trace line origins beyond the shallow boundary, and any tool depending on full history produces incomplete or misleading results. This is by design, not a bug.",
      "fail_rate": 0.92,
      "sources": [
        "https://git-scm.com/docs/shallow"
      ],
      "condition": ""
    },
    {
      "action": "Running git merge-base to find common ancestors in a shallow clone",
      "why_fails": "merge-base requires reachable common ancestors between branches. In a shallow clone the commit graph is truncated, so merge-base either fails with a fatal error or returns incorrect results. This breaks rebase workflows and merge conflict resolution that depend on accurate base detection.",
      "fail_rate": 0.88,
      "sources": [
        "https://git-scm.com/docs/git-merge-base"
      ],
      "condition": ""
    },
    {
      "action": "Repeatedly fetching with small incremental depth increases to avoid downloading full history",
      "why_fails": "Each git fetch --depth=N fetches from the tip, not from the current shallow boundary. Incrementally increasing depth is unreliable for reaching specific commits and can trigger 'shallow file has changed' race conditions when done concurrently. The total data transferred often exceeds a single --unshallow operation.",
      "fail_rate": 0.7,
      "sources": [
        "https://git-scm.com/docs/git-fetch"
      ],
      "condition": ""
    }
  ],
  "workarounds": [
    {
      "action": "Convert shallow clone to full clone with git fetch --unshallow",
      "success_rate": 0.95,
      "how": "Run 'git fetch --unshallow' to download the complete commit history. This converts the shallow clone into a full clone. After this, all git operations (log, blame, merge-base, rebase) work correctly. In CI, add this step before any operation that requires history.",
      "sources": [
        "https://git-scm.com/docs/git-fetch#Documentation/git-fetch.txt---unshallow"
      ],
      "condition": ""
    },
    {
      "action": "Fetch a specific depth sufficient for the required operation",
      "success_rate": 0.85,
      "how": "Run 'git fetch --depth=N' where N is large enough to include the commits you need (e.g., depth=100 for recent blame, depth=500 for a merge-base within the last year). Check with 'git rev-list --count HEAD' to confirm you have enough history.",
      "tradeoff": "Faster than --unshallow but may still be insufficient for operations requiring very old commits",
      "sources": [
        "https://git-scm.com/docs/git-fetch"
      ],
      "condition": "When full unshallow is too slow for CI time budgets"
    },
    {
      "action": "Use blobless clone (--filter=blob:none) instead of shallow clone",
      "success_rate": 0.92,
      "how": "Clone with 'git clone --filter=blob:none <repo-url>'. This downloads all commits and trees but fetches file contents (blobs) on demand. You get full commit history for log, blame, and merge-base, while still saving significant bandwidth and disk space on initial clone.",
      "tradeoff": "First checkout of files is slower as blobs are fetched on demand; requires Git 2.19+ and server-side partial clone support",
      "sources": [
        "https://git-scm.com/docs/partial-clone"
      ],
      "condition": "When you need full history but want to minimize clone size"
    }
  ],
  "transition_graph": {
    "leads_to": [
      {
        "error_id": "git/merge-conflict-markers/git2-linux",
        "probability": 0.2,
        "condition": "After unshallowing, a rebase or merge may surface conflicts that were invisible with truncated history"
      }
    ],
    "preceded_by": [],
    "frequently_confused_with": [
      {
        "error_id": "git/shallow-update-not-allowed/git2-linux",
        "distinction": "'fatal: shallow file has changed since we read it' vs 'fatal: refusing to fetch into branch because shallow update ': while both are git errors in the clone_error category, the former Shallow clones (depth=1) lack full commit history, breaking operations that requ while the latter Git operation on a shallow clone that requires full history."
      }
    ]
  },
  "metadata": {
    "generated_by": "manual",
    "generation_date": "2026-02-14",
    "review_status": "human_reviewed",
    "evidence_count": 55,
    "last_verification": "2026-02-14"
  }
}
