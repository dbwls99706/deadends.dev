{
  "schema_version": "1.0.0",
  "id": "go/grpc-unavailable/go1.22-linux",
  "url": "https://deadends.dev/go/grpc-unavailable/go1.22-linux",
  "error": {
    "signature": "rpc error: code = Unavailable desc = connection error: desc = \"transport: Error while dialing: dial tcp: lookup service: no such host\"",
    "regex": "rpc error: code = Unavailable|grpc.*Unavailable|transport:.*Error while dialing",
    "domain": "go",
    "category": "grpc_error",
    "first_seen": "2023-01-01",
    "last_confirmed": "2026-02-12"
  },
  "environment": {
    "runtime": {
      "name": "go",
      "version_range": ">=1.22,<2.0"
    },
    "os": "linux"
  },
  "verdict": {
    "resolvable": "partial",
    "fix_success_rate": 0.80,
    "confidence": 0.85,
    "last_updated": "2026-02-12",
    "summary": "gRPC UNAVAILABLE status indicates the service cannot be reached. Causes: server not running, DNS resolution failure, TLS mismatch, or load balancer health check failure."
  },
  "dead_ends": [
    {
      "action": "Increase gRPC MaxRecvMsgSize to fix connection errors",
      "why_fails": "MaxRecvMsgSize controls message size limits, not connection establishment — UNAVAILABLE means the transport layer cannot connect",
      "fail_rate": 0.90,
      "sources": [
        "https://pkg.go.dev/google.golang.org/grpc"
      ],
      "condition": ""
    },
    {
      "action": "Disable gRPC keepalive pings",
      "why_fails": "Keepalives detect dead connections — disabling them hides connection failures without fixing the root cause",
      "fail_rate": 0.75,
      "sources": [
        "https://pkg.go.dev/google.golang.org/grpc/keepalive"
      ],
      "condition": ""
    }
  ],
  "workarounds": [
    {
      "action": "Verify the gRPC server is running and the address is correct",
      "success_rate": 0.88,
      "how": "Use grpcurl to test: grpcurl -plaintext localhost:50051 list\nCheck if the server is listening: ss -tlnp | grep 50051",
      "sources": [
        "https://github.com/fullstorydev/grpcurl"
      ],
      "condition": ""
    },
    {
      "action": "Match TLS configuration between client and server",
      "success_rate": 0.85,
      "how": "If server uses grpc.Creds(), client must use grpc.WithTransportCredentials(). If server uses insecure, client must use grpc.WithTransportCredentials(insecure.NewCredentials()).",
      "sources": [
        "https://pkg.go.dev/google.golang.org/grpc#WithTransportCredentials"
      ],
      "condition": "when one side uses TLS and the other does not"
    }
  ],
  "transition_graph": {
    "leads_to": [
      {
        "error_id": "go/context-deadline-exceeded/go1-linux",
        "probability": 0.25,
        "condition": "when gRPC connection retries exhaust the context deadline"
      }
    ],
    "preceded_by": [
      {
        "error_id": "go/net-dial-timeout/go1.22-linux",
        "probability": 0.25,
        "condition": "when TCP dial fails underneath gRPC transport"
      }
    ],
    "frequently_confused_with": [
      {
        "error_id": "go/connection-refused/go1-linux",
        "distinction": "gRPC UNAVAILABLE wraps various transport errors (DNS, TLS, connection refused) into a single status code, while 'connection refused' is a specific TCP-level error."
      }
    ]
  },
  "metadata": {
    "generated_by": "bulk_generate.py",
    "generation_date": "2026-02-12",
    "review_status": "auto_generated",
    "evidence_count": 50,
    "last_verification": "2026-02-12"
  }
}
