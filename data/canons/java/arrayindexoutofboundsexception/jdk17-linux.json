{
  "schema_version": "1.0.0",
  "id": "java/arrayindexoutofboundsexception/jdk17-linux",
  "url": "https://deadends.dev/java/arrayindexoutofboundsexception/jdk17-linux",
  "error": {
    "signature": "java.lang.ArrayIndexOutOfBoundsException",
    "regex": "java\\.lang\\.ArrayIndexOutOfBoundsException",
    "domain": "java",
    "category": "runtime_error",
    "first_seen": "2023-01-01",
    "last_confirmed": "2026-02-12"
  },
  "environment": {
    "runtime": {
      "name": "java",
      "version_range": ">=17,<21"
    },
    "os": "linux"
  },
  "verdict": {
    "resolvable": "true",
    "fix_success_rate": 0.95,
    "confidence": 0.96,
    "last_updated": "2026-02-12",
    "summary": "ArrayIndexOutOfBoundsException is thrown when code accesses an array element with an index that is negative or greater than or equal to the array length. The error message includes the invalid index value."
  },
  "dead_ends": [
    {
      "action": "Catching ArrayIndexOutOfBoundsException to return a default value instead of fixing the indexing logic",
      "why_fails": "Using try-catch for array bounds is an anti-pattern in Java. Exceptions are expensive to create (stack trace capture), and this approach hides logic bugs. The incorrect index indicates a flaw in the algorithm â€” a loop boundary error, an off-by-one error, or an assumption about data size that is violated.",
      "fail_rate": 0.75,
      "sources": [
        "https://docs.oracle.com/en/java/javase/21/docs/api/"
      ],
      "condition": ""
    },
    {
      "action": "Pre-allocating a very large array to avoid bounds issues",
      "why_fails": "Over-allocating arrays wastes memory and does not fix the indexing logic. If the index is computed incorrectly (e.g., negative, or based on wrong input), a larger array only raises the threshold before failure without fixing the root cause. It can also cause OutOfMemoryError.",
      "fail_rate": 0.7,
      "sources": [
        "https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/OutOfMemoryError.html"
      ],
      "condition": ""
    }
  ],
  "workarounds": [
    {
      "action": "Check the array length before accessing and fix the loop boundary or index computation",
      "success_rate": 0.95,
      "how": "1. Read the error message to find the invalid index and the file:line where it occurred. 2. Check loop boundaries: use 'i < array.length' not 'i <= array.length' (off-by-one). 3. For direct access: validate 'index >= 0 && index < array.length' before accessing. 4. Common causes: empty array from unexpected input, concurrent modification of shared array, String.split() returning fewer parts than expected. 5. Consider using a List<T> instead of arrays for dynamic sizing.",
      "sources": [],
      "condition": ""
    },
    {
      "action": "Use Collections (ArrayList, List) instead of arrays for dynamic data, and use List utility methods for safe access",
      "success_rate": 0.9,
      "how": "1. Replace arrays with ArrayList<T> for dynamic sizing. 2. Use list.isEmpty() checks before accessing elements. 3. For getting the last element safely: list.get(list.size() - 1) with a size check, or use Guava's Iterables.getLast(list, defaultValue). 4. Use ListIterator for safe indexed iteration. 5. For fixed-size indexed data, use EnumMap or a Map<Integer, T> to avoid index-based bugs.",
      "sources": [],
      "condition": ""
    }
  ],
  "transition_graph": {
    "leads_to": [
      {
        "error_id": "java/nullpointerexception/jdk17-linux",
        "probability": 0.1,
        "condition": "when bounds check returns null default value that is used without null handling"
      },
      {
        "error_id": "java/outofmemoryerror-heap/jdk17-linux",
        "probability": 0.05,
        "condition": "when over-allocation workaround creates excessively large arrays"
      }
    ],
    "preceded_by": [
      {
        "error_id": "java/nullpointerexception/jdk17-linux",
        "probability": 0.08,
        "condition": "when null-check workaround initializes an empty array that is later accessed without length check"
      },
      {
        "error_id": "java/jackson-deserialization/jdk17-linux",
        "probability": 0.05,
        "condition": "when JSON deserialization produces a shorter array than expected"
      }
    ],
    "frequently_confused_with": [
      {
        "error_id": "java/illegalstateexception/jdk17-linux",
        "distinction": "ArrayIndexOutOfBoundsException is specifically about array/list index being out of range; IllegalStateException is about an object being in the wrong state. StringIndexOutOfBoundsException is a sibling for String character access."
      }
    ]
  },
  "metadata": {
    "generated_by": "bulk_generate.py",
    "generation_date": "2026-02-12",
    "review_status": "auto_generated",
    "evidence_count": 80,
    "last_verification": "2026-02-12"
  }
}
