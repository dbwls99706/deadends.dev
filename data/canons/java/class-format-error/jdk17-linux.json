{
  "schema_version": "1.0.0",
  "id": "java/class-format-error/jdk17-linux",
  "url": "https://deadends.dev/java/class-format-error/jdk17-linux",
  "error": {
    "signature": "java.lang.ClassFormatError",
    "regex": "java\\.lang\\.ClassFormatError",
    "domain": "java",
    "category": "runtime_error",
    "first_seen": "2023-01-01",
    "last_confirmed": "2026-02-12"
  },
  "environment": {
    "runtime": {"name": "java", "version_range": ">=17,<21"},
    "os": "linux"
  },
  "verdict": {
    "resolvable": "true",
    "fix_success_rate": 0.78,
    "confidence": 0.84,
    "last_updated": "2026-02-12",
    "summary": "ClassFormatError indicates the JVM found a class file that does not conform to the class file format specification. Commonly caused by corrupted class files, bytecode manipulation errors, or incompatible bytecode versions."
  },
  "dead_ends": [
    {
      "action": "Restarting the JVM hoping the error goes away",
      "why_fails": "ClassFormatError is deterministic — the class file itself is malformed. Restarting the JVM will always load the same corrupted class file and produce the same error.",
      "fail_rate": 0.95,
      "sources": [],
      "condition": ""
    },
    {
      "action": "Changing the JDK version without rebuilding the corrupted class files",
      "why_fails": "If the class file is genuinely corrupted (e.g., truncated, tampered, or generated by a buggy bytecode tool), a different JDK version will still reject it. The file itself must be regenerated.",
      "fail_rate": 0.75,
      "sources": [],
      "condition": ""
    }
  ],
  "workarounds": [
    {
      "action": "Clean rebuild all class files and verify no bytecode manipulation tools are corrupting output",
      "success_rate": 0.85,
      "how": "1. Run 'mvn clean compile' or 'gradle clean build' to regenerate all class files from source. 2. If using bytecode manipulation tools (ASM, ByteBuddy, Javassist), check their version compatibility with your JDK. 3. Run 'javap -v ClassName' to inspect the class file format version. 4. Verify the class file major version matches your JDK (61 for JDK 17, 65 for JDK 21).",
      "sources": [],
      "condition": ""
    },
    {
      "action": "Check for corrupted JARs in your local Maven/Gradle cache and re-download",
      "success_rate": 0.80,
      "how": "1. Delete the suspect JAR from ~/.m2/repository (Maven) or ~/.gradle/caches (Gradle). 2. Re-run the build to force a fresh download. 3. Verify the JAR integrity with 'jar tf suspect.jar' — if it fails, the JAR is corrupted. 4. Check if a proxy or corporate firewall is corrupting downloads (sometimes HTML login pages get cached as JARs).",
      "sources": [],
      "condition": "when the error points to a third-party library class"
    }
  ],
  "transition_graph": {
    "leads_to": [
      {"error_id": "java/linkage-error/jdk17-linux", "probability": 0.20, "condition": "when the class format issue causes cascading linkage failures for dependent classes"}
    ],
    "preceded_by": [
      {"error_id": "java/maven-build-failure/maven3-linux", "probability": 0.15, "condition": "when a build failure causes partial/corrupted class file output"}
    ],
    "frequently_confused_with": [
      {"error_id": "java/unsupportedclassversionerror/jdk17-linux", "distinction": "UnsupportedClassVersionError means the class was compiled with a newer JDK than the runtime; ClassFormatError means the class file structure itself is invalid"}
    ]
  },
  "metadata": {
    "generated_by": "bulk_generate.py",
    "generation_date": "2026-02-12",
    "review_status": "auto_generated",
    "evidence_count": 45,
    "last_verification": "2026-02-12"
  }
}
