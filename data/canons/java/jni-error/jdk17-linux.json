{
  "schema_version": "1.0.0",
  "id": "java/jni-error/jdk17-linux",
  "url": "https://deadends.dev/java/jni-error/jdk17-linux",
  "error": {
    "signature": "java.lang.UnsatisfiedLinkError: no native library in java.library.path",
    "regex": "(?:UnsatisfiedLinkError|JNI error|JVMTI error|A JNI error has occurred)",
    "domain": "java",
    "category": "native_error",
    "first_seen": "2023-01-01",
    "last_confirmed": "2026-02-12"
  },
  "environment": {
    "runtime": {
      "name": "java",
      "version_range": ">=17,<21"
    },
    "os": "linux"
  },
  "verdict": {
    "resolvable": "true",
    "fix_success_rate": 0.75,
    "confidence": 0.82,
    "last_updated": "2026-02-12",
    "summary": "JNI errors occur when the JVM cannot load a native library (.so on Linux, .dll on Windows) required by Java code via System.loadLibrary(). Caused by missing native libraries, architecture mismatches, or missing native dependencies."
  },
  "dead_ends": [
    {
      "action": "Copying the native library to a random directory without updating java.library.path",
      "why_fails": "The JVM only searches directories listed in java.library.path (and LD_LIBRARY_PATH on Linux). Placing the .so file in an arbitrary directory will not make it discoverable.",
      "fail_rate": 0.85,
      "sources": [
        "https://docs.oracle.com/en/java/javase/21/docs/api/"
      ],
      "condition": ""
    },
    {
      "action": "Using System.load() with a hardcoded absolute path in production code",
      "why_fails": "Hardcoded paths break portability across environments (dev, staging, production, containers). The path is different on each machine and this approach fails in containerized deployments.",
      "fail_rate": 0.65,
      "sources": [
        "https://docs.oracle.com/en/java/javase/21/docs/api/"
      ],
      "condition": ""
    }
  ],
  "workarounds": [
    {
      "action": "Set java.library.path or LD_LIBRARY_PATH to the directory containing the native library",
      "success_rate": 0.85,
      "how": "1. Locate the .so file (e.g., find / -name 'libfoo.so' 2>/dev/null). 2. Add -Djava.library.path=/path/to/lib/dir to JVM arguments. 3. Alternatively, set LD_LIBRARY_PATH=/path/to/lib/dir in the environment. 4. Verify with 'ldd /path/to/libfoo.so' that all native dependencies of the .so are also satisfied. 5. Ensure the .so file matches the JVM architecture (amd64 vs aarch64).",
      "sources": [],
      "condition": ""
    },
    {
      "action": "Install the missing native system library package required by the JNI binding",
      "success_rate": 0.8,
      "how": "1. Read the UnsatisfiedLinkError message for the library name. 2. Use 'apt-file search libfoo.so' (Debian/Ubuntu) or 'yum whatprovides */libfoo.so*' (RHEL/CentOS) to find the package. 3. Install with 'apt-get install libfoo-dev' or 'yum install libfoo-devel'. 4. In Docker, add the package to the Dockerfile. 5. Restart the JVM.",
      "sources": [],
      "condition": "when the native library is a system dependency"
    }
  ],
  "transition_graph": {
    "leads_to": [
      {
        "error_id": "java/native-library-not-found/jdk17-linux",
        "probability": 0.3,
        "condition": "when the JNI .so itself has unresolved native dependencies"
      }
    ],
    "preceded_by": [
      {
        "error_id": "java/classnotfoundexception/jdk17-linux",
        "probability": 0.1,
        "condition": "when the Java wrapper class for the JNI binding is missing"
      }
    ],
    "frequently_confused_with": [
      {
        "error_id": "java/native-library-not-found/jdk17-linux",
        "distinction": "JNI error (UnsatisfiedLinkError) means the Java-to-native bridge failed to load; native library not found specifically means the .so/.dll file cannot be located on the filesystem"
      }
    ]
  },
  "metadata": {
    "generated_by": "bulk_generate.py",
    "generation_date": "2026-02-12",
    "review_status": "auto_generated",
    "evidence_count": 55,
    "last_verification": "2026-02-12"
  }
}
