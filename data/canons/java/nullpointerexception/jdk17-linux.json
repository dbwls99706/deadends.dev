{
  "schema_version": "1.0.0",
  "id": "java/nullpointerexception/jdk17-linux",
  "url": "https://deadends.dev/java/nullpointerexception/jdk17-linux",
  "error": {
    "signature": "java.lang.NullPointerException",
    "regex": "java\\.lang\\.NullPointerException",
    "domain": "java",
    "category": "runtime_error",
    "first_seen": "2023-01-01",
    "last_confirmed": "2026-02-12"
  },
  "environment": {
    "runtime": {
      "name": "java",
      "version_range": ">=17,<21"
    },
    "os": "linux"
  },
  "verdict": {
    "resolvable": "true",
    "fix_success_rate": 0.95,
    "confidence": 0.96,
    "last_updated": "2026-02-12",
    "summary": "NullPointerException occurs when code attempts to use a null reference where an object is required. JDK 17+ provides helpful NullPointerException messages that pinpoint the exact null variable."
  },
  "dead_ends": [
    {
      "action": "Adding null checks everywhere without understanding the root cause of the null value",
      "why_fails": "Defensive null checks mask the real bug. The null value often indicates a missing initialization, incorrect dependency injection, or a logic error upstream. Scattering null checks treats the symptom, not the disease, and leads to bloated, hard-to-maintain code.",
      "fail_rate": 0.65,
      "sources": [
        "https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/NullPointerException.html"
      ],
      "condition": ""
    },
    {
      "action": "Catching NullPointerException with a try-catch block and silently ignoring it",
      "why_fails": "Swallowing NullPointerException hides bugs. The program continues in an invalid state, causing data corruption or delayed failures that are much harder to diagnose later.",
      "fail_rate": 0.85,
      "sources": [
        "https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/NullPointerException.html"
      ],
      "condition": ""
    },
    {
      "action": "Returning null from methods as a default fallback to avoid the exception in the caller",
      "why_fails": "Returning null just moves the NullPointerException to a different call site. It propagates the null further through the codebase, making it harder to trace the origin of the problem.",
      "fail_rate": 0.6,
      "sources": [
        "https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/NullPointerException.html"
      ],
      "condition": ""
    }
  ],
  "workarounds": [
    {
      "action": "Read the JDK 17+ helpful NullPointerException message to identify exactly which variable or method return was null, then trace back to where that value should have been initialized",
      "success_rate": 0.95,
      "how": "1. Read the exception message carefully â€” JDK 17+ prints which exact expression was null (e.g., 'Cannot invoke method because \"this.service\" is null'). 2. Trace the variable to its initialization point. 3. Determine why initialization was skipped (missing constructor arg, failed dependency injection, conditional path). 4. Fix the root cause by ensuring the value is always properly initialized before use.",
      "sources": [],
      "condition": ""
    },
    {
      "action": "Use Optional<T> for values that may legitimately be absent, and use Objects.requireNonNull() for values that must never be null",
      "success_rate": 0.9,
      "how": "1. For method parameters that must not be null, add Objects.requireNonNull(param, 'param must not be null') at the method entry. This fails fast with a clear message. 2. For return types that may be absent, return Optional<T> instead of null. 3. Use Optional.map(), Optional.orElse(), Optional.orElseThrow() to handle the absent case explicitly. 4. Enable @NonNull/@Nullable annotations with static analysis tools like NullAway or Checker Framework to catch null issues at compile time.",
      "sources": [],
      "condition": ""
    }
  ],
  "transition_graph": {
    "leads_to": [
      {
        "error_id": "java/illegalstateexception/jdk17-linux",
        "probability": 0.15,
        "condition": "when null check is replaced with a state validation that throws IllegalStateException"
      },
      {
        "error_id": "java/stackoverflowerror/jdk17-linux",
        "probability": 0.05,
        "condition": "when recursive null-check workaround causes infinite recursion"
      }
    ],
    "preceded_by": [
      {
        "error_id": "java/classnotfoundexception/jdk17-linux",
        "probability": 0.1,
        "condition": "when a class fails to load and the reference remains null"
      },
      {
        "error_id": "java/spring-autowire-failed/spring6-linux",
        "probability": 0.2,
        "condition": "when Spring autowiring silently fails and injected field is null"
      }
    ],
    "frequently_confused_with": [
      {
        "error_id": "java/illegalstateexception/jdk17-linux",
        "distinction": "IllegalStateException means the object exists but is in a wrong state; NullPointerException means the object reference itself is null"
      }
    ]
  },
  "metadata": {
    "generated_by": "bulk_generate.py",
    "generation_date": "2026-02-12",
    "review_status": "auto_generated",
    "evidence_count": 120,
    "last_verification": "2026-02-12"
  }
}
