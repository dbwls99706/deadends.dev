{
  "schema_version": "1.0.0",
  "id": "java/optimistic-lock-exception/jdk17-linux",
  "url": "https://deadends.dev/java/optimistic-lock-exception/jdk17-linux",
  "error": {
    "signature": "javax.persistence.OptimisticLockException: Row was updated or deleted by another transaction",
    "regex": "OptimisticLockException|StaleObjectStateException|Row was updated or deleted by another transaction",
    "domain": "java",
    "category": "persistence_error",
    "first_seen": "2010-01-01",
    "last_confirmed": "2026-02-14"
  },
  "environment": {
    "runtime": {
      "name": "jdk",
      "version_range": ">=11,<22"
    },
    "os": "linux"
  },
  "verdict": {
    "resolvable": "true",
    "fix_success_rate": 0.85,
    "confidence": 0.88,
    "last_updated": "2026-02-14",
    "summary": "Another transaction modified the same entity between read and write. The @Version field doesn't match, so JPA/Hibernate rejects the update to prevent lost updates. Common in high-concurrency scenarios."
  },
  "dead_ends": [
    {
      "action": "Removing the @Version field to disable optimistic locking",
      "why_fails": "Removes the safety mechanism that prevents lost updates. Concurrent modifications will silently overwrite each other, causing data corruption.",
      "fail_rate": 0.8,
      "sources": [
        "https://docs.jboss.org/hibernate/orm/6.2/userguide/html_single/Hibernate_User_Guide.html#locking-optimistic"
      ],
      "condition": ""
    },
    {
      "action": "Catching the exception and blindly retrying the same update",
      "why_fails": "Retrying with the same stale data will hit the same version conflict. The entity must be re-fetched before retrying.",
      "fail_rate": 0.9,
      "sources": [
        "https://docs.oracle.com/javaee/7/api/javax/persistence/OptimisticLockException.html"
      ],
      "condition": ""
    }
  ],
  "workarounds": [
    {
      "action": "Implement retry logic that re-fetches the entity before each attempt",
      "how": "int retries = 3;\nwhile (retries-- > 0) {\n    try {\n        Entity e = repository.findById(id).orElseThrow();\n        e.setField(newValue);\n        repository.save(e);\n        break;\n    } catch (OptimisticLockException ex) {\n        if (retries == 0) throw ex;\n    }\n}",
      "success_rate": 0.9,
      "sources": [
        "https://docs.jboss.org/hibernate/orm/6.2/userguide/html_single/Hibernate_User_Guide.html#locking-optimistic"
      ],
      "condition": ""
    },
    {
      "action": "Use pessimistic locking for high-contention entities",
      "how": "@Lock(LockModeType.PESSIMISTIC_WRITE)\n@Query(\"SELECT e FROM Entity e WHERE e.id = :id\")\nOptional<Entity> findByIdForUpdate(@Param(\"id\") Long id);",
      "success_rate": 0.88,
      "sources": [
        "https://docs.spring.io/spring-data/jpa/reference/jpa/locking.html"
      ],
      "condition": "High contention on the same rows"
    }
  ],
  "transition_graph": {
    "leads_to": [],
    "preceded_by": [],
    "frequently_confused_with": [
      {
        "error_id": "java/concurrentmodificationexception/jdk17-linux",
        "distinction": "ConcurrentModificationException is an in-memory collection error (iterating while modifying). OptimisticLockException is a database-level concurrent modification conflict."
      }
    ]
  },
  "metadata": {
    "generated_by": "expert_review",
    "generation_date": "2026-02-14",
    "review_status": "auto_generated",
    "evidence_count": 70,
    "last_verification": "2026-02-14"
  }
}
