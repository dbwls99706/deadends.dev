{
  "schema_version": "1.0.0",
  "id": "java/serialization-version-mismatch/jdk17-linux",
  "url": "https://deadends.dev/java/serialization-version-mismatch/jdk17-linux",
  "error": {
    "signature": "java.io.InvalidClassException: local class incompatible: stream classdesc serialVersionUID mismatch",
    "regex": "java\\.io\\.InvalidClassException.*serialVersionUID|local class incompatible",
    "domain": "java",
    "category": "serialization_error",
    "first_seen": "2023-01-01",
    "last_confirmed": "2026-02-12"
  },
  "environment": {
    "runtime": {
      "name": "java",
      "version_range": ">=17,<21"
    },
    "os": "linux"
  },
  "verdict": {
    "resolvable": "true",
    "fix_success_rate": 0.82,
    "confidence": 0.87,
    "last_updated": "2026-02-12",
    "summary": "The serialVersionUID of the class being deserialized does not match the serialVersionUID of the local class definition. This means the class has been modified since the serialized data was written, and Java considers the versions incompatible."
  },
  "dead_ends": [
    {
      "action": "Changing the serialVersionUID in the current class to match the old serialized data",
      "why_fails": "If the class structure has actually changed (fields added/removed/renamed), forcing the serialVersionUID to match will not make the data compatible. Deserialization may succeed but produce corrupted objects with null or wrong field values.",
      "fail_rate": 0.6,
      "sources": [
        "https://docs.oracle.com/en/java/javase/21/docs/api/"
      ],
      "condition": "when the class structure has materially changed"
    },
    {
      "action": "Ignoring the error and re-serializing all data",
      "why_fails": "If the serialized data is in persistent storage (files, databases, caches, message queues) being actively used by other services, re-serializing is not always possible. Other services may still send the old format.",
      "fail_rate": 0.55,
      "sources": [
        "https://docs.oracle.com/en/java/javase/21/docs/api/"
      ],
      "condition": "in distributed systems with shared serialized data"
    }
  ],
  "workarounds": [
    {
      "action": "Always declare an explicit serialVersionUID in serializable classes to control version compatibility",
      "success_rate": 0.9,
      "how": "1. Add 'private static final long serialVersionUID = 1L;' to every Serializable class. 2. Only change it when making intentionally incompatible changes. 3. For compatible changes (adding optional fields), keep the same serialVersionUID. 4. Use 'serialver com.example.MyClass' to find the current auto-generated UID if you need to set it retroactively. 5. This prevents future mismatches from accidental class modifications.",
      "sources": [],
      "condition": ""
    },
    {
      "action": "Implement custom readObject/writeObject or migrate to a versioned format like JSON or Protobuf",
      "success_rate": 0.85,
      "how": "1. For backward compatibility, implement readObject() with version detection: read a version field first, then deserialize accordingly. 2. For new systems, use Jackson JSON, Protobuf, or Avro instead of Java serialization â€” these formats have built-in schema evolution support. 3. For caches (Redis, Memcached), invalidate all cached data when the class changes. 4. For message queues, use a format with schema registry (Avro + Confluent Schema Registry).",
      "sources": [],
      "condition": ""
    }
  ],
  "transition_graph": {
    "leads_to": [
      {
        "error_id": "java/jackson-deserialization/jdk17-linux",
        "probability": 0.15,
        "condition": "when migrating from Java serialization to Jackson JSON introduces new deserialization errors"
      }
    ],
    "preceded_by": [
      {
        "error_id": "java/classnotfoundexception/jdk17-linux",
        "probability": 0.1,
        "condition": "when the class definition changes package or name, causing ClassNotFoundException before the UID check"
      }
    ],
    "frequently_confused_with": [
      {
        "error_id": "java/jackson-deserialization/jdk17-linux",
        "distinction": "Jackson deserialization errors are about JSON-to-Java mapping; serialVersionUID mismatch is specific to Java's built-in binary serialization mechanism"
      }
    ]
  },
  "metadata": {
    "generated_by": "bulk_generate.py",
    "generation_date": "2026-02-12",
    "review_status": "auto_generated",
    "evidence_count": 55,
    "last_verification": "2026-02-12"
  }
}
