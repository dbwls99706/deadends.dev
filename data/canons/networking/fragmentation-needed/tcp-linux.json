{
  "schema_version": "1.0.0",
  "id": "networking/fragmentation-needed/tcp-linux",
  "url": "https://deadends.dev/networking/fragmentation-needed/tcp-linux",
  "error": {
    "signature": "ICMP: Fragmentation Needed and Don't Fragment was Set (mtu 1400)",
    "regex": "Fragmentation Needed|PMTU|frag needed|message too long|EMSGSIZE|need to frag",
    "domain": "networking",
    "category": "mtu_pmtud",
    "first_seen": "2023-01-01",
    "last_confirmed": "2026-02-12"
  },
  "environment": {
    "runtime": {"name": "tcp", "version_range": "any"},
    "os": "linux"
  },
  "verdict": {
    "resolvable": "true",
    "fix_success_rate": 0.88,
    "confidence": 0.90,
    "last_updated": "2026-02-12",
    "summary": "A router along the path cannot forward a packet because it exceeds the link MTU and the Don't Fragment (DF) bit is set. The router sends an ICMP Fragmentation Needed message. If ICMP is blocked, PMTUD fails silently and connections hang after the initial handshake (PMTUD black hole)."
  },
  "dead_ends": [
    {
      "action": "Clear the DF bit on all outgoing packets to allow fragmentation",
      "why_fails": "IP fragmentation causes significant performance degradation, increases packet loss probability, and some firewalls drop fragments. Modern TCP relies on PMTUD to avoid fragmentation entirely.",
      "fail_rate": 0.70,
      "sources": [],
      "condition": ""
    },
    {
      "action": "Block ICMP entirely for security, breaking PMTUD",
      "why_fails": "Blocking ICMP type 3 code 4 (Fragmentation Needed) breaks Path MTU Discovery completely. Connections that need PMTUD will hang after the handshake when data packets exceed the path MTU.",
      "fail_rate": 0.90,
      "sources": [],
      "condition": ""
    }
  ],
  "workarounds": [
    {
      "action": "Reduce the interface MTU to match the path MTU",
      "success_rate": 0.90,
      "how": "1. Discover the path MTU: ping -M do -s 1472 destination (reduce size until it works)\n2. Set the interface MTU: ip link set dev eth0 mtu 1400\n3. For tunnels (VPN, VXLAN), account for encapsulation overhead\n4. Verify: ping -M do -s $((MTU-28)) destination\n5. Make persistent in /etc/network/interfaces or via NetworkManager",
      "sources": [],
      "condition": ""
    },
    {
      "action": "Enable TCP MSS clamping to avoid PMTUD issues",
      "success_rate": 0.92,
      "how": "1. Clamp MSS at the firewall: iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu\n2. Or set a specific MSS: iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss 1360\n3. This adjusts the TCP MSS option in SYN packets so data segments fit within the path MTU\n4. Verify with tcpdump: tcpdump -i eth0 'tcp[tcpflags] & tcp-syn != 0' -v | grep mss",
      "sources": [],
      "condition": ""
    }
  ],
  "transition_graph": {
    "leads_to": [
      {"error_id": "networking/connection-timeout/tcp-linux", "probability": 0.35, "condition": "when ICMP is blocked and PMTUD fails silently, causing connections to hang (PMTUD black hole)"},
      {"error_id": "networking/mtu-too-large/tcp-linux", "probability": 0.30, "condition": "when the MTU mismatch causes persistent packet drops on the path"}
    ],
    "preceded_by": [
      {"error_id": "networking/mtu-too-large/tcp-linux", "probability": 0.25, "condition": "when an MTU configuration exceeds the path MTU and triggers fragmentation needed"}
    ],
    "frequently_confused_with": [
      {"error_id": "networking/mtu-too-large/tcp-linux", "distinction": "Fragmentation needed is the ICMP message generated by a router; MTU too large is the configuration error on the sending host"}
    ]
  },
  "metadata": {
    "generated_by": "bulk_generate.py",
    "generation_date": "2026-02-12",
    "review_status": "auto_generated",
    "evidence_count": 55,
    "last_verification": "2026-02-12"
  }
}
