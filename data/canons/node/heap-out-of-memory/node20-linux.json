{
  "schema_version": "1.0.0",
  "id": "node/heap-out-of-memory/node20-linux",
  "url": "https://deadend.dev/node/heap-out-of-memory/node20-linux",

  "error": {
    "signature": "FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory",
    "regex": "FATAL ERROR: (?:CALL_AND_RETRY_LAST|Reached heap limit) Allocation failed - JavaScript heap out of memory",
    "domain": "node",
    "category": "memory",
    "first_seen": "2016-03-01",
    "last_confirmed": "2025-05-10"
  },

  "environment": {
    "runtime": { "name": "node", "version_range": ">=18,<23" },
    "os": "linux",
    "additional": {}
  },

  "verdict": {
    "resolvable": "true",
    "fix_success_rate": 0.78,
    "confidence": 0.85,
    "last_updated": "2025-05-10",
    "summary": "Heap out of memory in Node 20 on Linux is commonly caused by large dataset processing, memory leaks in long-running processes, or aggressive bundler configurations. Increasing the heap limit is a valid short-term fix, but long-term resolution requires identifying the memory consumer."
  },

  "dead_ends": [
    {
      "action": "Blindly setting --max-old-space-size to very large values (e.g., 32768) without investigating the root cause",
      "why_fails": "Raising the heap limit without understanding why memory is exhausted merely delays the crash. If there is a memory leak, the process will eventually exhaust even the larger limit, and on constrained environments (containers, CI) this causes OOM kills. This masks the real problem.",
      "fail_rate": 0.60,
      "sources": [
        "https://nodejs.org/en/docs/guides/diagnostics/memory/using-heap-snapshot"
      ],
      "common_misconception": "Many developers treat --max-old-space-size as a permanent solution rather than a diagnostic aid. The default heap limit exists to catch runaway memory usage early."
    },
    {
      "action": "Upgrading Node.js version alone",
      "why_fails": "While newer Node versions may have slightly different default heap limits and improved GC, upgrading does not fix application-level memory leaks or fundamentally undersized heaps for legitimate workloads.",
      "fail_rate": 0.85,
      "sources": []
    }
  ],

  "workarounds": [
    {
      "action": "Increase heap size via NODE_OPTIONS environment variable",
      "how": "export NODE_OPTIONS='--max-old-space-size=4096' && node app.js. For build tools: NODE_OPTIONS='--max-old-space-size=4096' npm run build. Adjust the value (in MB) based on available system memory. Common values: 4096 (4GB), 8192 (8GB).",
      "success_rate": 0.82,
      "tradeoff": "Higher memory consumption; does not fix underlying leaks; may cause OOM kill in memory-constrained containers",
      "sources": [
        "https://nodejs.org/api/cli.html#node_optionsoptions"
      ]
    },
    {
      "action": "Profile and fix memory leaks using heap snapshots",
      "how": "Run with --inspect flag: 'node --inspect app.js'. Open chrome://inspect in Chrome, take heap snapshots before and after the operation, compare retained objects. Look for growing arrays, event listener accumulation, or unclosed streams.",
      "success_rate": 0.70,
      "tradeoff": "Requires debugging expertise and time investment; not suitable for production profiling without overhead considerations",
      "sources": [
        "https://nodejs.org/en/docs/guides/diagnostics/memory/using-heap-snapshot"
      ]
    },
    {
      "action": "Process data in streams or chunks instead of loading everything into memory",
      "how": "Replace fs.readFileSync or full-buffer approaches with Node.js streams (fs.createReadStream, Transform streams). For JSON, use streaming parsers like 'stream-json' or 'JSONStream' instead of JSON.parse on the full file.",
      "success_rate": 0.75,
      "tradeoff": "Requires refactoring code to use streaming patterns; adds complexity to error handling",
      "condition": "Error occurs when processing large files or datasets",
      "sources": []
    }
  ],

  "transition_graph": {
    "leads_to": [
      {
        "error_id": "node/process-oom-killed/node20-linux",
        "probability": 0.40,
        "condition": "When heap limit is raised beyond available system memory, the Linux OOM killer terminates the process",
        "typical_delay": "minutes to hours"
      }
    ],
    "preceded_by": [
      {
        "error_id": "node/gc-warning-ineffective/node20-linux",
        "probability": 0.20,
        "condition": "Node may emit GC-related warnings before the final heap exhaustion crash"
      }
    ],
    "frequently_confused_with": [
      {
        "error_id": "node/segfault-native-module/node20-linux",
        "distinction": "Heap out of memory produces a FATAL ERROR message from V8. Segfaults from native modules produce a different signal (SIGSEGV) with no V8 error message. Check if the crash message contains 'FATAL ERROR' vs a signal number."
      }
    ]
  },

  "metadata": {
    "generated_by": "deadend-seed-v1",
    "generation_date": "2025-06-01",
    "review_status": "auto_generated",
    "evidence_count": 45,
    "page_views": 0,
    "ai_agent_hits": 0,
    "human_hits": 0,
    "last_verification": "2025-06-01"
  }
}
