{
  "schema_version": "1.0.0",
  "id": "node/sqlite-busy-database-locked/node20-linux",
  "url": "https://deadends.dev/node/sqlite-busy-database-locked/node20-linux",
  "error": {
    "signature": "Error: SQLITE_BUSY: database is locked",
    "regex": "SQLITE_BUSY.*database is locked",
    "domain": "node",
    "category": "database_error",
    "first_seen": "2019-01-01",
    "last_confirmed": "2026-02-14"
  },
  "environment": {
    "runtime": {
      "name": "node",
      "version_range": ">=18,<23"
    },
    "os": "linux"
  },
  "verdict": {
    "resolvable": "true",
    "fix_success_rate": 0.85,
    "confidence": 0.88,
    "last_updated": "2026-02-14",
    "summary": "SQLite database is locked by another connection or process. Common in Node.js apps using better-sqlite3 or sqlite3 with concurrent writes, especially in serverless environments or when WAL mode is not enabled."
  },
  "dead_ends": [
    {
      "action": "Adding retry loops with short delays to wait for the lock",
      "why_fails": "Retries can work for occasional contention, but under sustained concurrent writes, retries create thundering herd problems and increase latency without solving the root cause.",
      "fail_rate": 0.6,
      "sources": [
        "https://www.sqlite.org/wal.html"
      ],
      "condition": "High write concurrency"
    },
    {
      "action": "Opening multiple database connections for parallel writes",
      "why_fails": "SQLite only allows one writer at a time regardless of how many connections are open. Multiple connections increase lock contention.",
      "fail_rate": 0.85,
      "sources": [
        "https://www.sqlite.org/lockingv3.html"
      ],
      "condition": ""
    }
  ],
  "workarounds": [
    {
      "action": "Enable WAL (Write-Ahead Logging) mode for concurrent read/write",
      "how": "db.pragma('journal_mode = WAL');\n// Or for sqlite3 package:\ndb.run('PRAGMA journal_mode=WAL;');",
      "success_rate": 0.9,
      "sources": [
        "https://www.sqlite.org/wal.html"
      ],
      "condition": ""
    },
    {
      "action": "Use a single shared database connection with a write queue",
      "how": "Serialize all write operations through a single connection. Use a queue (e.g., p-queue with concurrency=1) to ensure only one write happens at a time.",
      "success_rate": 0.88,
      "sources": [
        "https://github.com/WiseLibs/better-sqlite3/blob/master/docs/threads.md"
      ],
      "condition": ""
    },
    {
      "action": "Set busy_timeout to wait for locks instead of failing immediately",
      "how": "db.pragma('busy_timeout = 5000');\n// Waits up to 5 seconds for the lock to be released",
      "success_rate": 0.82,
      "sources": [
        "https://www.sqlite.org/pragma.html#pragma_busy_timeout"
      ],
      "condition": "Low to moderate contention"
    }
  ],
  "transition_graph": {
    "leads_to": [],
    "preceded_by": [],
    "frequently_confused_with": [
      {
        "error_id": "database/sqlite-locked/sqlite3-linux",
        "distinction": "Same underlying SQLite error but in different runtime contexts. The Node.js variant often involves async I/O patterns and connection pooling unique to Node."
      }
    ]
  },
  "metadata": {
    "generated_by": "expert_review",
    "generation_date": "2026-02-14",
    "review_status": "auto_generated",
    "evidence_count": 85,
    "last_verification": "2026-02-14"
  }
}
