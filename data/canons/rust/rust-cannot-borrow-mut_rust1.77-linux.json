{
  "schema_version": "1.0.0",
  "id": "rust/rust-cannot-borrow-mut/rust1.77-linux",
  "url": "https://deadends.dev/rust/rust-cannot-borrow-mut/rust1.77-linux",
  "error": {
    "signature": "cannot borrow `*self` as mutable because it is also borrowed as immutable",
    "regex": "cannot borrow.*as mutable.*also borrowed as immutable",
    "domain": "rust",
    "category": "borrow_error",
    "first_seen": "2023-01-01",
    "last_confirmed": "2026-02-12"
  },
  "environment": {
    "runtime": {
      "name": "rust",
      "version_range": ">=1.70,<2.0"
    },
    "os": "linux"
  },
  "verdict": {
    "resolvable": "true",
    "fix_success_rate": 0.87,
    "confidence": 0.9,
    "last_updated": "2026-02-12",
    "summary": "Simultaneous mutable and immutable borrows violate Rust's aliasing rules. Restructure code to separate borrow scopes."
  },
  "dead_ends": [
    {
      "action": "Use unsafe block to force mutable access while immutable reference exists",
      "why_fails": "Undefined behavior; the compiler relies on aliasing guarantees for optimization",
      "fail_rate": 0.95,
      "sources": [
        "https://doc.rust-lang.org/nomicon/aliasing.html"
      ],
      "condition": ""
    },
    {
      "action": "Clone the entire struct to avoid borrow conflicts",
      "why_fails": "Excessive memory usage and doesn't fix the underlying design issue; changes may be lost",
      "fail_rate": 0.6,
      "sources": [
        "https://doc.rust-lang.org/error_codes/"
      ],
      "condition": ""
    }
  ],
  "workarounds": [
    {
      "action": "Extract the immutable read into a local variable before the mutable borrow",
      "success_rate": 0.9,
      "how": "let value = self.field.clone();\nself.other_field = transform(value);",
      "sources": [
        "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"
      ],
      "condition": ""
    },
    {
      "action": "Use interior mutability with Cell or RefCell",
      "success_rate": 0.85,
      "how": "use std::cell::RefCell;\nlet field = RefCell::new(value);\n// Now you can borrow_mut() independently",
      "sources": [
        "https://doc.rust-lang.org/std/cell/index.html"
      ],
      "condition": ""
    }
  ],
  "transition_graph": {
    "leads_to": [
      {
        "error_id": "rust/e0499-mutable-borrow-twice/rust1-linux",
        "probability": 0.25,
        "condition": "When restructuring introduces a second mutable borrow"
      }
    ],
    "preceded_by": [
      {
        "error_id": "rust/e0502-mutable-immutable-borrow/rust1-linux",
        "probability": 0.2,
        "condition": "When refactoring borrow conflict code"
      }
    ],
    "frequently_confused_with": [
      {
        "error_id": "rust/e0502-mutable-immutable-borrow/rust1-linux",
        "distinction": "E0502 is the compiler error code for this pattern; rust-cannot-borrow-mut is the general borrow conflict message"
      }
    ]
  },
  "metadata": {
    "generated_by": "bulk_generate.py",
    "generation_date": "2026-02-12",
    "review_status": "auto_generated",
    "evidence_count": 50,
    "last_verification": "2026-02-12"
  }
}
